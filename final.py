# -*- coding: utf-8 -*-
"""Final.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1eWtOW-3UXmT85I2C7WCDda-5olKVh3qP

### Universidad de San Carlos de Guatemala

### Escuela de Ciencias F√≠sicas y Matem√°ticas

*F√≠sica Computacional*

**Catedr√°tico:** *MsC. Juan Diego Chang*


**Estudiante:** *Melissa Gatica Arriola*

**Carn√©:** *201709692*

# Proyecto Final "Modelo de Ising"



---

1. Escribir un c√≥digo que calcule la energ√≠a E y la magnetizaci√≥n M del modelo de Ising para una configuraci√≥n œÜ. La magnetizaci√≥n es el par√°metro de orden del sistema. Est√° definida por

$$
M = ‚àë_i \frac{s_i}{L^2} = ‚àë_{i,i=1} \frac{Œ¶(i,j)}{L^2}
.
$$
"""

import numpy as np
import random
import seaborn as sns
import matplotlib.pyplot as plt

# Definiendo variables
J = 1
H = 4
L = 50
T = np.linspace(0.1, 10, 100)
temperatures = np.linspace(0.1, 10, 100)
iteraciones = 15000

# Generar red inicial aleatoria
red = np.random.choice([-1, 1], size=(L, L))
phi = np.random.choice([-1, 1], size=(L, L))

# Visualizaci√≥n inicial
sns.heatmap(red)
plt.title("Configuraci√≥n inicial")
plt.show()


# Funcion para calcular energia
def calcular_energia(red, J, H):
  E_0 = 0
  magnetizacion = 0

  for i in range(L):
      for j in range(L):
          # Suma de interacciones con vecinos
          vecinos = (
              red[(i + 1) % L, j] +
              red[(i - 1) % L, j] +
              red[i, (j + 1) % L] +
              red[i, (j - 1) % L]
          )
          # Energ√≠a total
          E_0 += -J * red[i, j] * vecinos - H * red[i, j]
          # Magnetizaci√≥n
          magnetizacion += red[i, j]/(L*L)

  # Dividir la energ√≠a para evitar el doble conteo
  return E_0 / 2, magnetizacion

# Resultados
E_0, magnetizacion_0 = calcular_energia(red, J, H)
print(f"Energ√≠a inicial: {E_0}")
print(f"Magnetizaci√≥n inicial: {magnetizacion_0}")

"""Escribir un c√≥digo que implemente el algoritmo de Metr√≥polis para este
sistema. La variaci√≥n de la energ√≠a dada por el cambio de esp√≠n œÜ (i, j)
est√° dada por

$$
Œî E=2JŒ¶(i,j)(Œ¶(i+1,j)+\phi(i-1,j)+\phi(i,j+1)+Œ¶(i,j-1))+2HŒ¶(i,j)
$$
"""

#Algoritmo Metropolis para simular la evolucion en el tiempo

def metropolis(red, J, H, T, iteraciones):
    for _ in range(iteraciones):
        i, j = np.random.randint(0, L, size=2)
        delta_E = 2 * J * red[i, j] * (
            red[(i + 1) % L, j] +
            red[(i - 1) % L, j] +
            red[i, (j + 1) % L] +
            red[i, (j - 1) % L]
        ) + 2 * H * red[i, j]

        if delta_E < 0 or np.random.rand() < np.exp(-delta_E / T):
            red[i, j] = -red[i, j]
    return red

# Simulaci√≥n para distintas temperaturas
M = []  # Magnetizaci√≥n promedio
E_total = []  # Energ√≠a promedio

for T in temperatures:
    red = metropolis(red, J, H, T, iteraciones)
    E = calcular_energia(red, J, H)
    M.append(np.mean(red))  # Promedio de espines
    E_total.append(E)  # Energ√≠a total

sns.heatmap(red)
plt.show()
sns.heatmap(red0)
plt.show()

# Gr√°ficos de resultados
plt.figure(figsize=(10, 5))

# Magnetizaci√≥n vs Temperatura
plt.subplot(1, 2, 1)
plt.plot(temperatures, M)
plt.xlabel('Temperatura')
plt.ylabel('Magnetizaci√≥n')
plt.title('Magnetizaci√≥n vs Temperatura')

# Energ√≠a vs Temperatura
plt.subplot(1, 2, 2)
plt.plot(temperatures, E_total)
plt.xlabel('Temperatura')
plt.ylabel('Energ√≠a')
plt.title('Energ√≠a vs Temperatura')

plt.tight_layout()
plt.show()

"""3. Elegimos ahora a L = 10, H = 0, J = 1, Œ≤ = 1/T. Consideramos un
arranque en fr√≠o y uno en caliente que est√°n dados por œÜ (i, j) = +1 para
todo i, j y œÜ (i, j) con signos aleatorios. Ejecute el algoritmo de Metr√≥polis
para un tiempo de termalizaci√≥n T T = 213 y estudiar la evoluci√≥n de la
energ√≠a y la magnetizaci√≥n para distintos valores de temperatura (elija una
temperatura baja T = 0,1, una media T = 3 y una alta T = 100). Recorte
los tiempos en las gr√°ficas si es necesario.
"""

temperatures = [0.1, 3, 100]
L = 10
J = 1
H = 0
red = np.random.choice([-1, 1], size=(L, L))
TT = 2**13

# Inicializaci√≥n y simulaci√≥n
for T in temperatures:
    # Condiciones iniciales
    red_frio = np.ones((L, L))  # Arranque en fr√≠o
    red_caliente = np.random.choice([-1, 1], size=(L, L))  # Arranque en caliente

# Almacenar resultados
    energia_frio, magnetizacion_frio = [], []
    energia_caliente, magnetizacion_caliente = [], []

# Simular para cada paso de tiempo
    for t in range(TT):
        metropolis(red_frio, J, H, T, 3)
        metropolis(red_caliente, J, H, T, 3)

        if t % 100 == 0:  # Guardar resultados cada 100 pasos
            E_f, M_f = calcular_energia(red_frio, J, H)
            E_c, M_c = calcular_energia(red_caliente, J, H)

            energia_frio.append(E_f)
            magnetizacion_frio.append(M_f)
            energia_caliente.append(E_c)
            magnetizacion_caliente.append(M_c)


    # Graficar energ√≠a
    plt.figure(figsize=(10, 5))
    plt.plot(energia_frio, label='Arranque en fr√≠o')
    plt.plot(energia_caliente, label='Arranque en caliente')
    plt.title(f"Evoluci√≥n de la energ√≠a para T = {T}")
    plt.xlabel("Tiempo (iteraciones/100)")
    plt.ylabel("Energ√≠a")
    plt.legend()
    plt.show()

    # Graficar magnetizaci√≥n
    plt.figure(figsize=(10, 5))
    plt.plot(magnetizacion_frio, label='Arranque en fr√≠o')
    plt.plot(magnetizacion_caliente, label='Arranque en caliente')
    plt.title(f"Evoluci√≥n de la magnetizaci√≥n para T = {T}")
    plt.xlabel("Tiempo (iteraciones/100)")
    plt.ylabel("Magnetizaci√≥n")
    plt.legend()
    plt.show()

"""4. Calcule el calor espec√≠fico y la susceptibilidad del sistema definidas por
$$
C_v = \frac{\partial E}{\partial Œ≤} = \frac{Œ≤}{T}(<E^2>-<E>^2)
$$

$$
ùòü = \frac{\partial M}{\partial H}= Œ≤ (<M^2>- <M>^2)
$$

Determinar el punto cr√≠tico y comparar el resultado con el resultado te√≥rico

$$
K_BT_c= \frac{2J}{ln(\sqrt(2)+1)}
$$
"""

# Simulaci√≥n
kB = 1
Cv = []
chi = []
Tc_teo = 2 * J / np.log(np.sqrt(2) + 1)  # Punto cr√≠tico te√≥rico
temperatura_critica = 0
max_Cv = 0

def metropolisCX(red, J, H, T, iteraciones):
    energias = []
    magnetizaciones = []
    for _ in range(iteraciones):
        i, j = np.random.randint(0, L, size=2)
        delta_E = 2 * J * red[i, j] * (
            red[(i + 1) % L, j] +
            red[(i - 1) % L, j] +
            red[i, (j + 1) % L] +
            red[i, (j - 1) % L]
        ) + 2 * H * red[i, j]

        if delta_E < 0 or np.random.rand() < np.exp(-delta_E / T):
            red[i, j] = -red[i, j]

        # Calcular energ√≠a y magnetizaci√≥n en cada paso
        energia, magnetizacion = calcular_energia(red, J, H)
        energias.append(energia)
        magnetizaciones.append(magnetizacion)

    return red, np.array(energias), np.array(magnetizaciones)


for T in temperatures:
    beta = 1 / (kB * Tc_teo)

    result = metropolisCX(red, J, H, T, iteraciones)
    energias = result[1]
    magnetizaciones = result[2]

    # Promedios y promedios cuadrados
    E_mean = np.mean(energias)
    E2_mean = np.mean(energias**2)
    M_mean = np.mean(magnetizaciones)
    M2_mean = np.mean(magnetizaciones**2)

    # Calor espec√≠fico
    cv = beta**2 * (E2_mean - E_mean**2)
    Cv.append(cv)

    # Susceptibilidad
    chi_val = beta * (M2_mean - M_mean**2)
    chi.append(chi_val)

    # Identificar el punto cr√≠tico
    if cv > max_Cv:
        max_Cv = cv
        temperatura_critica = T

# Gr√°ficas
plt.figure(figsize=(12, 6))

# Gr√°fica de C_v
plt.subplot(1, 2, 1)
plt.plot(temperatures, Cv, label="Calor espec√≠fico $C_v$")
plt.axvline(Tc_teo, color='red', linestyle='--', label=f"$T_c$ te√≥rico: {Tc_teo:.2f}")
plt.axvline(temperatura_critica, color='blue', linestyle='--', label=f"$T_c$ simulado: {temperatura_critica:.2f}")
plt.xlabel('Temperatura $T$')
plt.ylabel('$C_v$')
plt.legend()
plt.title('Calor espec√≠fico vs Temperatura')

# Gr√°fica de susceptibilidad
plt.subplot(1, 2, 2)
plt.plot(temperatures, chi, label="Susceptibilidad $\chi$")
plt.axvline(Tc_teo, color='red', linestyle='--', label=f"$T_c$ te√≥rico: {Tc_teo:.2f}")
plt.axvline(temperatura_critica, color='blue', linestyle='--', label=f"$T_c$ simulado: {temperatura_critica:.2f}")
plt.xlabel('Temperatura $T$')
plt.ylabel('$\chi$')
plt.legend()
plt.title('Susceptibilidad vs Temperatura')

plt.tight_layout()
plt.show()

"""# Parte 2
Verifique este comportamiento num√©ricamente. Para esto, tomamos redes
con tama√±os L = 10 hasta L = 30 con TT = 2^{13}. La temperatura se toma
en el rango de T = Tc ‚àí 10‚àí2n, con n = ‚àí50, ‚àí49, ¬∑ ¬∑ ¬∑ , 49, 50. Trazar el m√°ximo de Cv L2 respecto de ln (L).
"""

Tc = 2 * J / np.log(np.sqrt(2) + 1)  # Punto cr√≠tico te√≥rico
L_values = range(10, 31)  # Tama√±os de red
n_values = np.arange(-50, 51)  # Valores de n
ln_L = np.log(L_values)  # ln(L) para graficar

max_Cv_L2 = []  # Lista para almacenar los m√°ximos de Cv/L^2

for L in L_values:
    Cv_L2 = []  # Lista para almacenar Cv/L^2 para cada T
    for n in n_values:
        T = Tc - 10.0**(-2 * n)
        red = np.random.choice([-1, 1], size=(L, L))  # Red inicial aleatoria
        energias = metropolis(red, J, H, T, iteraciones)

        # Calcular Cv
        beta = 1 / (kB * T)
        E_mean = np.mean(energias)
        E2_mean = np.mean(energias**2)
        cv = beta / T * (E2_mean - E_mean**2)

        # Escalar por L^2
        Cv_L2.append(cv / L**2)

    # Almacenar el m√°ximo de Cv/L^2
    max_Cv_L2.append(max(Cv_L2))

# Graficar m√°ximo de Cv/L^2 vs ln(L)
plt.figure(figsize=(8, 6))
plt.plot(ln_L, max_Cv_L2, 'o-', label=r'$\max(C_v / L^2)$')
plt.xlabel(r'$\ln(L)$')
plt.ylabel(r'$\max(C_v / L^2)$')
plt.title(r'Comportamiento de $\max(C_v / L^2)$ respecto a $\ln(L)$')
plt.legend()
plt.grid(True)
plt.show()